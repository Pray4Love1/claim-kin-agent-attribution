"""Helpers for parsing Hyperliquid deployment transaction logs.

The attribution tooling occasionally receives semi-structured export files
produced by block explorers or bespoke deployment pipelines.  These files are
typically JSON-like but may contain additional framing metadata or multiple
transaction arrays.  The :func:`load_transactions` helper implemented here
extracts the transaction details that are relevant for attribution claims and
returns a normalised list of dictionaries.

In addition to the parsing helper we expose :func:`format_summary` and
:func:`print_summary` to render a human-readable overview of the deployments.
"""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any, Dict, List, Mapping, Optional, Sequence

_TRANSACTION_BLOCK_PATTERN = re.compile(
    r"\"transactions\"\s*:\s*\[(.*?)\](?=\s*(?:[}\]]|$))", re.DOTALL
)


def _stringify(value: Any) -> Optional[str]:
    """Return ``value`` as a string when meaningful."""

    if value is None:
        return None
    if isinstance(value, str):
        stripped = value.strip()
        return stripped or None
    if isinstance(value, (int, float)):
        return str(value)
    return str(value)


def _parse_transactions_block(block: str) -> List[Mapping[str, Any]]:
    """Parse the inner contents of a ``"transactions": [...]`` block."""

    candidate = f"[{block}]"
    try:
        parsed = json.loads(candidate)
    except json.JSONDecodeError:
        candidate = "[" + block.rstrip().rstrip(",") + "]"
        parsed = json.loads(candidate)

    if not isinstance(parsed, list):
        return []

    transactions: List[Mapping[str, Any]] = []
    for entry in parsed:
        if isinstance(entry, Mapping):
            transactions.append(entry)
    return transactions


def load_transactions(path: str | Path) -> List[Dict[str, Optional[str]]]:
    """Load deployment transactions from ``path``.

    Parameters
    ----------
    path:
        Text file containing one or more ``"transactions"`` arrays.
    """

    content = Path(path).read_text(encoding="utf-8")

    blocks = _TRANSACTION_BLOCK_PATTERN.findall(content)
    if not blocks:
        raise ValueError("No transactions block found.")

    results: List[Dict[str, Optional[str]]] = []
    for block in blocks:
        for entry in _parse_transactions_block(block):
            transaction = entry.get("transaction")
            if not isinstance(transaction, Mapping):
                transaction = {}

            record: Dict[str, Optional[str]] = {
                "contractAddress": _stringify(entry.get("contractAddress")),
                "hash": _stringify(entry.get("hash")),
                "chainId": _stringify(transaction.get("chainId")),
                "from": _stringify(transaction.get("from")),
            }
            results.append(record)

    return results


def format_summary(transactions: Sequence[Mapping[str, Optional[str]]]) -> str:
    """Return a human-readable summary for ``transactions``."""

    lines: List[str] = ["", f"ðŸ§  Parsed {len(transactions)} contract deployments:", ""]

    for tx in transactions:
        contract = tx.get("contractAddress") or "<unknown>"
        hash_ = tx.get("hash") or "<unknown>"
        chain_id = tx.get("chainId") or "<unknown>"
        sender = tx.get("from") or "<unknown>"

        lines.extend(
            [
                f"ðŸ“¦ Contract:  {contract}",
                f"ðŸ”— Tx Hash:   {hash_}",
                f"ðŸŒ Chain ID:  {chain_id}",
                f"ðŸš€ From:      {sender}",
                "-" * 60,
            ]
        )

    return "\n".join(lines)


def print_summary(transactions: Sequence[Mapping[str, Optional[str]]]) -> None:
    """Print the summary generated by :func:`format_summary`."""

    print(format_summary(transactions))


__all__ = [
    "format_summary",
    "load_transactions",
    "print_summary",
]

